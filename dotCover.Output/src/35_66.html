<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>/home/runner/work/Html2Markdown/Html2Markdown/src/Html2Markdown/Replacement/HtmlParser.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System.Net;
using System.Text.RegularExpressions;
using HtmlAgilityPack;

namespace Html2Markdown.Replacement;

internal static partial class HtmlParser
{

	internal static string ReplaceLists(string html)
	{
		var finalHtml = html;
		var lastRun = string.Empty;
		while (HasNoChildLists(finalHtml))
		{
			var listToReplace = HtmlListHasNoChildren().Match(finalHtml).Value;
			var formattedList = ReplaceList(listToReplace);
			
			// an empty  signifies that the HTML is malformed in some way.
			// so we should leave the final HTML as is
			if (string.IsNullOrEmpty(formattedList)) {
				finalHtml = finalHtml.Replace(listToReplace, lastRun);
				break;
			}

			lastRun = formattedList;
			
			finalHtml = finalHtml.Replace(listToReplace, formattedList);
		}

		return finalHtml;
	}

	private static string ReplaceList(string html)
	{
		var list = FindHtmlList().Match(html);
		var listType = list.Groups[1].Value;
		var listItems = FindHtmlListItems().Split(list.Groups[2].Value);
			
		if (ListOnlyHasEmptyStringsForChildren(listItems)) return string.Empty;
			
		listItems = listItems.Skip(1).ToArray();
			
		if (ListIsEmpty(listItems)) return string.Empty;
			
		var counter = 0;
		var markdownList = new List&lt;string&gt;();
		listItems.ToList().ForEach(listItem =&gt;
		{
			var listPrefix = listType.Equals(&quot;ol&quot;) ? $&quot;{++counter}.  &quot; : &quot;*   &quot;;
			//In case of multiline Html, a line can end with a new line. In this case we want to remove the closing tag as well as the new line
			//otherwise we may only keep the line breaks between tags and create a double line break in the markdown
			var closingTag = listItem.EndsWith($&quot;&lt;/li&gt;{Environment.NewLine}&quot;) ? $&quot;&lt;/li&gt;{Environment.NewLine}&quot; : &quot;&lt;/li&gt;&quot;;
			var finalList = listItem.Replace(closingTag, string.Empty);

			if (finalList.Trim().Length == 0) {
				return;
			}

			finalList = SpacesAtTheStartOfALine().Replace(finalList, string.Empty);
			finalList = TwoNewLines().Replace(finalList, $&quot;{Environment.NewLine}{Environment.NewLine}    &quot;);
			// indent nested lists
			finalList = NestedList().Replace(finalList, &quot;\n$1    $2&quot;);
			// remove the indent from the first line
			if (listItem.StartsWith(&quot;&lt;p&gt;&quot;))
			{
				finalList = ReplaceParagraph(finalList, true);
			}
			markdownList.Add($&quot;{listPrefix}{finalList}&quot;);
		});
		
		if (markdownList.Count == 0) return string.Empty;

		//If a new line is already ending the markdown item, then we don&#39;t need to add another one
		return Environment.NewLine + Environment.NewLine + markdownList.Aggregate((current, item) =&gt;  current.EndsWith(Environment.NewLine) ? current + item : current + Environment.NewLine + item) + Environment.NewLine + Environment.NewLine;
	}

	private static bool ListIsEmpty(IReadOnlyCollection&lt;string&gt; listItems)
	{
		return listItems.Count == 0;
	}

	private static bool ListOnlyHasEmptyStringsForChildren(IEnumerable&lt;string&gt; listItems)
	{
		return listItems.All(string.IsNullOrEmpty);
	}

	private static bool HasNoChildLists(string html)
	{
		return HtmlListHasNoChildren().Match(html).Success;
	}

	internal static string ReplacePre(string html)
	{
		var doc = GetHtmlDocument(html);
		var nodes = doc.DocumentNode.SelectNodes(&quot;//pre&quot;);
		if (nodes == null) {
			return html;
		}

		nodes.ToList().ForEach(node =&gt;
		{
			var tagContents = node.InnerHtml;
			var markdown = ConvertPre(tagContents);

			ReplaceNode(node, markdown);
		});

		return doc.DocumentNode.OuterHtml;
	}

	private static string ConvertPre(string html)
	{
		var tag = TabsToSpaces(html);
		tag = IndentNewLines(tag);
		return Environment.NewLine + Environment.NewLine + tag + Environment.NewLine;
	}

	private static string IndentNewLines(string tag)
	{
		return tag.Replace(Environment.NewLine, Environment.NewLine + &quot;    &quot;);
	}

	private static string TabsToSpaces(string tag)
	{
		return tag.Replace(&quot;\t&quot;, &quot;    &quot;);
	}

	internal static string ReplaceImg(string html)
	{
		var doc = GetHtmlDocument(html);
		var nodes = doc.DocumentNode.SelectNodes(&quot;//img&quot;);
		if (nodes == null) {
			return html;
		}

		nodes.ToList().ForEach(node =&gt;
		{
					
			var src = node.Attributes.GetAttributeOrEmpty(&quot;src&quot;);
			var alt = node.Attributes.GetAttributeOrEmpty(&quot;alt&quot;);
			var title = node.Attributes.GetAttributeOrEmpty(&quot;title&quot;);

			var markdown = $&quot;![{alt}]({src}{(title.Length &gt; 0 ? $&quot; \&quot;{title}\&quot;&quot; : &quot;&quot;)})&quot;;

			ReplaceNode(node, markdown);
		});

		return doc.DocumentNode.OuterHtml;
	}

	internal static string ReplaceAnchor(string html)
	{
		var doc = GetHtmlDocument(html);
		var nodes = doc.DocumentNode.SelectNodes(&quot;//a&quot;);
		if (nodes == null) {
			return html;
		}

		nodes.ToList().ForEach(node =&gt;
		{
			var linkText = node.InnerHtml;
			var href = node.Attributes.GetAttributeOrEmpty(&quot;href&quot;);
			var title = node.Attributes.GetAttributeOrEmpty(&quot;title&quot;);

			var markdown = &quot;&quot;;

			if (!IsEmptyLink(linkText, href))
			{
				markdown = $&quot;[{linkText}]({href}{(title.Length &gt; 0 ? $&quot; \&quot;{title}\&quot;&quot; : &quot;&quot;)})&quot;;
			}

			ReplaceNode(node, markdown);
		});

		return doc.DocumentNode.OuterHtml;
	}
	
	internal static string ReplaceCode(string html, bool supportSyntaxHighlighting)
	{
		var doc = GetHtmlDocument(html);
		var nodes = doc.DocumentNode.SelectNodes(&quot;//code&quot;);

		if (nodes == null) {
			return html;
		}

		nodes.ToList().ForEach(node =&gt;
		{
			var code = node.InnerHtml;
			var language = supportSyntaxHighlighting ? GetSyntaxHighlightLanguage(node) : &quot;&quot;;

			string markdown;
			if(IsSingleLineCodeBlock(code))
			{
				markdown = &quot;`&quot; + code + &quot;`&quot;;
			}
			else
			{
				markdown = ReplaceBreakTagsWithNewLines(code);
				markdown = InitialCrLf().Replace(markdown, &quot;&quot;);
				markdown = FinalCrLf().Replace(markdown, &quot;&quot;);
				markdown = &quot;```&quot; + language + Environment.NewLine + markdown + Environment.NewLine + &quot;```&quot;;
			}

			ReplaceNode(node, markdown);
		});

		return doc.DocumentNode.OuterHtml;
	}

	private static string ReplaceBreakTagsWithNewLines(string code)
	{
		return BreakTag().Replace(code, &quot;&quot;);
	}

	private static bool IsSingleLineCodeBlock(string code)
	{
		// single line code blocks do not have new line characters
		return !code.Contains(Environment.NewLine);
	}

	private static string GetSyntaxHighlightLanguage(HtmlNode node)
	{
		// extract the language for syntax highlighting from a code tag
		// depending on the implementations, language can be declared in the tag as :
		// &lt;code class=&quot;language-csharp&quot;&gt;
		// &lt;code class=&quot;lang-csharp&quot;&gt;
		// &lt;code class=&quot;csharp&quot;&gt;
		var classAttributeValue = node.Attributes[&quot;class&quot;]?.Value;

		if(string.IsNullOrEmpty(classAttributeValue)){
			return string.Empty;
		}

		if (!classAttributeValue.StartsWith(&quot;lang&quot;)) return classAttributeValue;
		var split =  classAttributeValue.Split(&#39;-&#39;);
				
		return split[^1]; // PERFORMANCE: https://sonarcloud.io/organizations/baynezy/rules?open=csharpsquid%3AS6608&amp;rule_key=csharpsquid%3AS6608

	}

	internal static string ReplaceBlockquote(string html)
	{
		var doc = GetHtmlDocument(html);
		var nodes = doc.DocumentNode.SelectNodes(&quot;//blockquote&quot;);
		if (nodes == null) {
			return html;
		}

		nodes.ToList().ForEach(node =&gt;
		{
			var quote = node.InnerHtml;
			var lines = quote.TrimStart().Split(new[] { Environment.NewLine }, StringSplitOptions.None);
			var markdown = &quot;&quot;;

			lines.ToList().ForEach(line =&gt;
			{
				markdown += $&quot;&gt; {line.TrimEnd()}{Environment.NewLine}&quot;;
			});

			markdown = EmptyQuoteLines().Replace(markdown, &quot;&quot;);

			markdown = Environment.NewLine + Environment.NewLine + markdown + Environment.NewLine + Environment.NewLine;

			ReplaceNode(node, markdown);
		});

		return doc.DocumentNode.OuterHtml;
	}

	internal static string ReplaceEntities(string html)
	{
		return WebUtility.HtmlDecode(html);
	}

	internal static string ReplaceParagraph(string html) =&gt; ReplaceParagraph(html, false);
	
	internal static string ReplaceHeading(string html, int headingNumber)
	{
		var tag = $&quot;h{headingNumber}&quot;;
		var doc = GetHtmlDocument(html);
		var nodes = doc.DocumentNode.SelectNodes($&quot;//{tag}&quot;);

		if (nodes is null) return html;
		
		nodes.ToList().ForEach(node =&gt;
		{
			var text = node.InnerHtml;
			var htmlRemoved = HtmlTags().Replace(text, &quot;&quot;);
			var markdown = Spaces().Replace(htmlRemoved, &quot; &quot;);
			markdown = markdown.Replace(Environment.NewLine, &quot; &quot;);
			markdown = Environment.NewLine + Environment.NewLine + new string(&#39;#&#39;, headingNumber) + &quot; &quot; + markdown + Environment.NewLine + Environment.NewLine;
			ReplaceNode(node, markdown);
		});
		
		return doc.DocumentNode.OuterHtml;
	}

	private static string ReplaceParagraph(string html, bool nestedIntoList)
	{
		var doc = GetHtmlDocument(html);
		var nodes = doc.DocumentNode.SelectNodes(&quot;//p&quot;);
		if (nodes == null) {
			return html;
		}

		nodes.ToList().ForEach(node =&gt;
		{
			var text = node.InnerHtml;
			var markdown = Spaces().Replace(text, &quot; &quot;);
			markdown = markdown.Replace(Environment.NewLine, &quot; &quot;);

			//If a paragraph is contained in a list, we don&#39;t want to add new line characters
			var openingTag = nestedIntoList ? &quot;&quot; : Environment.NewLine + Environment.NewLine;
			var closingTag = nestedIntoList ? &quot;&quot; : Environment.NewLine;

			markdown = openingTag + markdown + closingTag;
			ReplaceNode(node, markdown);
		});

		return doc.DocumentNode.OuterHtml;
	}

	private static bool IsEmptyLink(string linkText, string href)
	{
		var length = linkText.Length + href.Length;
		return length == 0;
	}

	private static HtmlDocument GetHtmlDocument(string html)
	{
		var doc = new HtmlDocument();
		doc.LoadHtml(html);
		return doc;
	}

	private static void ReplaceNode(HtmlNode node, string markdown)
	{
		if (string.IsNullOrEmpty(markdown))
		{
			node.ParentNode.RemoveChild(node);
		}
		else
		{
			node.ReplaceNodeWithString(markdown);
		}
	}

    [GeneratedRegex(@&quot;&lt;(ul|ol)\b[^&gt;]*&gt;([\s\S]*?)&lt;\/\1&gt;&quot;)]
    private static partial Regex FindHtmlList();
    [GeneratedRegex(@&quot;&lt;(ul|ol)\b[^&gt;]*&gt;(?:(?!&lt;ul|&lt;ol)[\s\S])*?&lt;\/\1&gt;&quot;)]
    private static partial Regex HtmlListHasNoChildren();
    [GeneratedRegex(&quot;&lt;li[^&gt;]*&gt;&quot;)]
    private static partial Regex FindHtmlListItems();
    [GeneratedRegex(@&quot;\s+&quot;)]
    private static partial Regex Spaces();
    [GeneratedRegex(@&quot;(&gt;\s\r?\n)+$&quot;)]
    private static partial Regex EmptyQuoteLines();
    [GeneratedRegex(@&quot;^\s+&quot;)]
    private static partial Regex SpacesAtTheStartOfALine();
    [GeneratedRegex(&quot;\\n{2}&quot;)]
    private static partial Regex TwoNewLines();
    [GeneratedRegex(@&quot;\n([ ]*)+(\*|\d+\.)&quot;)]
    private static partial Regex NestedList();
    [GeneratedRegex(&quot;^\r?\n&quot;)]
    private static partial Regex InitialCrLf();
    [GeneratedRegex(&quot;\r?\n$&quot;)]
    private static partial Regex FinalCrLf();
    [GeneratedRegex(@&quot;&lt;\s*?/?\s*?br\s*?&gt;&quot;)]
    private static partial Regex BreakTag();
    [GeneratedRegex(@&quot;&lt;[^&gt;]+&gt;&quot;)]
    private static partial Regex HtmlTags();
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[11,2,11,3,1],[12,3,12,24,1],[13,3,13,30,1],[14,3,14,37,1],[15,3,15,4,1],[16,4,16,71,1],[17,4,17,51,1],[21,4,21,44,1],[21,45,21,46,1],[22,5,22,59,1],[23,5,23,11,1],[26,4,26,28,1],[28,4,28,64,1],[29,3,29,4,1],[31,3,31,20,1],[32,2,32,3,1],[35,2,35,3,1],[36,3,36,41,1],[37,3,37,39,1],[38,3,38,67,1],[40,3,40,53,1],[40,54,40,74,1],[42,3,42,43,1],[44,3,44,30,1],[44,31,44,51,1],[46,3,46,19,1],[47,3,47,41,1],[48,3,49,3,1],[49,3,49,4,1],[49,4,50,4,1],[50,4,50,72,1],[50,72,53,4,1],[53,4,53,112,1],[53,112,54,4,1],[54,4,54,63,1],[54,63,56,4,1],[56,4,56,37,1],[56,37,56,38,1],[56,38,56,39,1],[56,39,57,5,1],[57,5,57,12,1],[57,12,60,4,1],[60,4,60,75,1],[60,75,61,4,1],[61,4,61,100,1],[61,100,63,4,1],[63,4,63,62,1],[63,62,65,4,1],[65,4,65,35,1],[65,35,66,4,1],[66,4,66,5,1],[66,5,67,5,1],[67,5,67,51,1],[67,51,68,4,1],[68,4,68,5,1],[68,5,69,4,1],[69,4,69,49,1],[69,49,70,3,1],[70,3,70,4,1],[70,4,70,6,1],[72,3,72,31,1],[72,32,72,52,1],[75,3,75,97,1],[75,97,75,190,1],[75,190,75,236,1],[76,2,76,3,1],[79,2,79,3,1],[80,3,80,31,1],[81,2,81,3,1],[84,2,84,3,1],[85,3,85,46,1],[86,2,86,3,1],[89,2,89,3,1],[90,3,90,54,1],[91,2,91,3,1],[94,2,94,3,1],[95,3,95,35,1],[96,3,96,53,1],[97,3,97,21,1],[97,22,97,23,1],[98,4,98,16,1],[101,3,102,3,1],[102,3,102,4,1],[102,4,103,4,1],[103,4,103,37,1],[103,37,104,4,1],[104,4,104,43,1],[104,43,106,4,1],[106,4,106,32,1],[106,32,107,3,1],[107,3,107,4,1],[107,4,107,6,1],[109,3,109,37,1],[110,2,110,3,1],[113,2,113,3,1],[114,3,114,32,1],[115,3,115,29,1],[116,3,116,80,1],[117,2,117,3,1],[120,2,120,3,1],[121,3,121,73,1],[122,2,122,3,1],[125,2,125,3,1],[126,3,126,36,1],[127,2,127,3,1],[130,2,130,3,1],[131,3,131,35,1],[132,3,132,53,1],[133,3,133,21,1],[133,22,133,23,1],[134,4,134,16,1],[137,3,138,3,1],[138,3,138,4,1],[138,4,140,4,1],[140,4,140,57,1],[140,57,141,4,1],[141,4,141,57,1],[141,57,142,4,1],[142,4,142,61,1],[142,61,144,4,1],[144,4,144,81,1],[144,81,146,4,1],[146,4,146,32,1],[146,32,147,3,1],[147,3,147,4,1],[147,4,147,6,1],[149,3,149,37,1],[150,2,150,3,1],[153,2,153,3,1],[154,3,154,35,1],[155,3,155,51,1],[156,3,156,21,1],[156,22,156,23,1],[157,4,157,16,1],[160,3,161,3,1],[161,3,161,4,1],[161,4,162,4,1],[162,4,162,34,1],[162,34,163,4,1],[163,4,163,59,1],[163,59,164,4,1],[164,4,164,61,1],[164,61,166,4,1],[166,4,166,22,1],[166,22,168,4,1],[168,4,168,37,1],[168,37,169,4,1],[169,4,169,5,1],[169,5,170,5,1],[170,5,170,83,1],[170,83,171,4,1],[171,4,171,5,1],[171,5,173,4,1],[173,4,173,32,1],[173,32,174,3,1],[174,3,174,4,1],[174,4,174,6,1],[176,3,176,37,1],[177,2,177,3,1],[180,2,180,3,1],[181,3,181,35,1],[182,3,182,54,1],[184,3,184,21,1],[184,22,184,23,1],[185,4,185,16,1],[188,3,189,3,1],[189,3,189,4,1],[189,4,190,4,1],[190,4,190,30,1],[190,30,191,4,1],[191,4,191,85,1],[191,85,194,4,1],[194,4,194,35,1],[194,35,195,4,1],[195,4,195,5,1],[195,5,196,5,1],[196,5,196,33,1],[196,33,197,4,1],[197,4,197,5,1],[197,5,199,4,1],[199,4,199,5,1],[199,5,200,5,1],[200,5,200,51,1],[200,51,201,5,1],[201,5,201,52,1],[201,52,202,5,1],[202,5,202,50,1],[202,50,203,5,1],[203,5,203,96,1],[203,96,204,4,1],[204,4,204,5,1],[204,5,206,4,1],[206,4,206,32,1],[206,32,207,3,1],[207,3,207,4,1],[207,4,207,6,1],[209,3,209,37,1],[210,2,210,3,1],[213,2,213,3,1],[214,3,214,39,1],[215,2,215,3,1],[218,2,218,3,1],[220,3,220,46,1],[221,2,221,3,1],[224,2,224,3,1],[230,3,230,61,1],[232,3,232,48,1],[232,48,232,49,1],[233,4,233,24,1],[236,3,236,47,1],[236,48,236,75,1],[237,3,237,47,1],[239,3,239,20,1],[241,2,241,3,1],[244,2,244,3,1],[245,3,245,35,1],[246,3,246,60,1],[247,3,247,21,1],[247,22,247,23,1],[248,4,248,16,1],[251,3,252,3,1],[252,3,252,4,1],[252,4,253,4,1],[253,4,253,31,1],[253,31,254,4,1],[254,4,254,96,1],[254,96,255,4,1],[255,4,255,22,1],[255,22,257,4,1],[257,4,258,4,1],[258,4,258,5,1],[258,5,259,5,1],[259,5,259,60,1],[259,60,260,4,1],[260,4,260,5,1],[260,5,260,7,1],[260,7,262,4,1],[262,4,262,55,1],[262,55,264,4,1],[264,4,264,112,1],[264,112,266,4,1],[266,4,266,32,1],[266,32,267,3,1],[267,3,267,4,1],[267,4,267,6,1],[269,3,269,37,1],[270,2,270,3,1],[273,2,273,3,1],[274,3,274,38,1],[275,2,275,3,1],[277,58,277,87,1],[280,2,280,3,1],[281,3,281,33,1],[282,3,282,35,1],[283,3,283,56,1],[285,3,285,21,1],[285,22,285,34,1],[287,3,288,3,1],[288,3,288,4,1],[288,4,289,4,1],[289,4,289,30,1],[289,30,290,4,1],[290,4,290,51,1],[290,51,291,4,1],[291,4,291,54,1],[291,54,292,4,1],[292,4,292,58,1],[292,58,293,4,1],[293,4,293,151,1],[293,151,294,4,1],[294,4,294,32,1],[294,32,295,3,1],[295,3,295,4,1],[295,4,295,6,1],[297,3,297,37,1],[298,2,298,3,1],[301,2,301,3,1],[302,3,302,35,1],[303,3,303,51,1],[304,3,304,21,1],[304,22,304,23,1],[305,4,305,16,1],[308,3,309,3,1],[309,3,309,4,1],[309,4,310,4,1],[310,4,310,30,1],[310,30,311,4,1],[311,4,311,47,1],[311,47,312,4,1],[312,4,312,58,1],[312,58,315,4,1],[315,4,315,85,1],[315,85,316,4,1],[316,4,316,63,1],[316,63,318,4,1],[318,4,318,50,1],[318,50,319,4,1],[319,4,319,32,1],[319,32,320,3,1],[320,3,320,4,1],[320,4,320,6,1],[322,3,322,37,1],[323,2,323,3,1],[326,2,326,3,1],[327,3,327,46,1],[328,3,328,22,1],[329,2,329,3,1],[332,2,332,3,1],[333,3,333,32,1],[334,3,334,22,1],[335,3,335,14,1],[336,2,336,3,1],[339,2,339,3,1],[340,3,340,38,1],[341,3,341,4,1],[342,4,342,38,1],[343,3,343,4,1],[345,3,345,4,1],[346,4,346,41,1],[347,3,347,4,1],[348,2,348,3,1]]);
    </script>
  </body>
</html>